diretÃ³rio dos metas
/var/db/repos/qmeta/category/pacote/pacote-versÃ£o.meta


qmeta --sync â€” sincronizar a Ã¡rvore de metas (fetch de novos .meta, atualizaÃ§Ãµes). 

qmeta --info â€” exibir informaÃ§Ãµes do sistema, ambiente,e configuraÃ§Ãµes usadas pelo qmeta 

qmeta --search <termo> ou -s <termo> â€” procurar pacotes cujo nome corresponde a termo ou parte dele. 

qmeta --searchdesc <termo> ou -S <termo> â€” procurar pacotes cujo nome ou descriÃ§Ã£o contenham o termo. 

qmeta --update ou -u â€” atualizar pacotes instalados para versÃµes mais recentes, respeitando mÃ¡scaras, etc. 

qmeta --update --deep ou -uD â€” atualizaÃ§Ã£o levando em conta dependÃªncias â€œprofundasâ€ (ou seja, dependÃªncias recursivas). 

qmeta --onlydeps â€” instalar somente dependÃªncias de um pacote, sem instalar o pacote em si. 

qmeta --remove ou -C â€” desinstalar pacotes especificados. 

qmeta--depclean â€” remover pacotes Ã³rfÃ£os (que nÃ£o sÃ£o mais necessÃ¡rios como dependÃªncias) do sistema. 

qmeta --pretend ou -p â€” simular o que o qmeta faria, sem realmente executar as mudanÃ§as. 

qmeta --verbose ou -v â€” mostrar mais informaÃ§Ã£o, dependÃªncias, e outros detalhes. 

qmeta --ask ou -a â€” perguntar confirmaÃ§Ã£o antes de proceder com operaÃ§Ãµes que alteram o sistema. 

qmeta --version ou -V â€” mostrar versÃ£o do qmeta

qmeta --list-sets â€” mostrar os "sets" disponÃ­veis (ex: @world, @systemâ€¦). 

qmeta --prune ou -P â€” remover versÃµes antigas instaladas de pacotes, mantendo apenas a mais recente, conforme critÃ©rios. 

qmeta --usepkg, --usepkgonly â€” usar pacotes binÃ¡rios (se disponÃ­veis) em vez de compilar tudo do zero. 

qmeta --noreplace â€” nÃ£o reinstalar pacotes jÃ¡ instalados; evitar recompilar se a versÃ£o instalada jÃ¡ satisfaz. 

qmeta --nodeps â€” instalar/desinstalar pacotes ignorando dependÃªncias (muito perigoso se nÃ£o souber o que estÃ¡ fazendo). 

qmeta --quiet-build â€” reduzir verbosidade durante o build/compilaÃ§Ã£o. 

qmeta --load-average â€” limitar a carga mÃ©dia permitida para builds paralelos. 

qmeta --jobs ou -j â€” nÃºmero de tasks paralelas no build. 

qmeta --keep-going â€” continuar mesmo se alguns pacotes falharem. 

qmeta --resume â€” retomar uma operaÃ§Ã£o de qmeta que foi interrompida. 

qmeta --fetchonly â€” apenas baixar as fontes (distfiles), sem compilar. 

qmeta python list
qmeta python set 3.12
Isso define qual python / python3 vai ser chamado globalmente.

ğŸŸ¢ python-exec

Wrapper usado para escolher dinamicamente a versÃ£o correta de Python para cada script.

Exemplo: quando vocÃª roda pip3, o python-exec redireciona para a versÃ£o de Python correspondente que foi instalada.

Isso garante que vocÃª possa ter, por exemplo, python3.10 e python3.12 no mesmo sistema sem conflitos.

ğŸ”¹ 3. classes especÃ­ficas de Python

Usar classes para facilitar .metas que dependem de Python:

python-r1 â†’ para pacotes que suportam mÃºltiplos Pythons.

python-single-r1 â†’ para pacotes que sÃ³ podem usar uma versÃ£o por vez.

distutils-r1 â†’ para pacotes Python instalados via setuptools ou distutils (a maioria dos pacotes PyPI).


Isso garante consistÃªncia entre .meta e evita duplicaÃ§Ã£o de lÃ³gica.

4. InstalaÃ§Ã£o de pacotes Python

 vocÃª instala pacotes Python como qualquer outro:

qmeta python/requests

Isso instala a versÃ£o de requests compilada contra os PYTHON_TARGETS que vocÃª definiu.
ğŸ“Œ Se vocÃª quiser gerenciar pacotes Python manualmente (fora do qmeta), pode usar pip, mas nÃ£o Ã© recomendado misturar com o que foi instalado pelo qmeta. O ideal Ã© usar virtualenv se quiser ambientes separados.

AtualizaÃ§Ãµes e mÃºltiplas versÃµes

Quando uma versÃ£o nova do Python chega

1. VocÃª instala ela (ex: qmeta extra/python:3.12).


2. Atualiza PYTHON_TARGETS no qmeta.conf.


3. Roda:

qmeta --upgrade --deep @world

Isso recompila pacotes Python com suporte para a nova versÃ£o.


4. Usa qmeta --set python para definir a versÃ£o padrÃ£o.
Portage Ã© escrito em Python â†’ precisa sempre de pelo menos uma versÃ£o instalada.

qmeta mantÃ©m mÃºltiplas versÃµes de Python em paralelo.

Ferramentas:

qmeta --set python â†’ escolher versÃ£o padrÃ£o.

python-exec â†’ escolher a versÃ£o certa por script.

(python_targets, python_single_target) â†’ definem quais versÃµes serÃ£o usadas pelos pacotes.


python-exec  (python-r1, distutils-r1) padronizam a forma de lidar com pacotes Python nos .meta

GCC Ã© instalado como slots â†’ vocÃª pode ter vÃ¡rias versÃµes lado a lado.
Exemplo:

/usr/x86_64-pc-linux-gnu/gcc-bin/12.3.0/
/usr/x86_64-pc-linux-gnu/gcc-bin/13.2.1/

Isso permite compilar pacotes com GCC antigo e novo sem conflito.


VocÃª seleciona a versÃ£o ativa com:

gcc-config -l
gcc-config 2
source /etc/profile

(gcc-config Ã© o equivalente ao script de python mas sÃ³ para GCC).

AtualizaÃ§Ã£o segura da toolchain

O processo recomendado Ã© em camadas:

1. Atualiza o binutils primeiro

qmeta -uav binutils
qmeta binutils list
qmeta binutils set X

â†’ Assim o linker/assembler jÃ¡ estÃ£o prontos.


2. Depois o GCC

qmeta -uav gcc
gcc-config -l
gcc-config X
source /etc/profile

â†’ Agora vocÃª jÃ¡ estÃ¡ usando o GCC novo.


3. Recompile libtool (garante compatibilidade de build systems):

qmeta -1 base/libtool


4. Por fim, recompile glibc (biblioteca C usa o GCC novo):

qmeta -uav glibc

Rebuild do mundo com novo GCC

Trocar GCC nÃ£o recompila nada automaticamente. Para reconstruir todo o sistema com o novo compilador:

qmeta -e @world

Isso recompila todos os pacotes. Ã‰ demorado, mas garante consistÃªncia.

Ferramentas extras

toolchainâ†’ que padroniza .meta do GCC, binutils, glibc.

base/gcc-config â†’ seleciona versÃ£o ativa do GCC.

base/binutils-config â†’ seleciona versÃ£o ativa do binutils.

crossdev â†’ permite montar toolchains cruzadas (ex: compilar para ARM em um PC x86).

qmeta crossdev
crossdev -t armv7a-unknown-linux-gnueabihf

Nunca hÃ¡ substituiÃ§Ã£o forÃ§ada â†’ sempre mantÃ©m mÃºltiplas versÃµes atÃ© vocÃª trocar.

glibc nunca Ã© slotado â†’ sÃ³ uma versÃ£o pode existir, porque ela Ã© Ãºnica para todo o sistema.

binutils e GCC sÃ£o slotados â†’ vÃ¡rias versÃµes convivem.

A troca Ã© feita com gcc-config / binutils-config.

qmeta-dist   # limpa tarballs antigos
qmeta-pkg    # limpa pacotes compilados antigos

glsa-check -t all   # lista pacotes vulnerÃ¡veis
glsa-check -f all   # corrige

revdep-rebuild 
ReconstrÃ³i pacotes quebrados por bibliotecas removidas/atualizadas.

revdep-rebuild



Comandos de manipulaÃ§Ã£o dos .meta

Ferramenta para interagir com arquivos .meta diretamente.
Sintaxe:

qmeta nome-do-pacote.meta <comando>

Comandos principais:

manifest â†’ gera/verifica Manifest (hashes das fontes).

fetch â†’ baixa o source (SRC_URI).

unpack â†’ extrai o source para o diretÃ³rio de trabalho.

compile â†’ compila o pacote.

install â†’ instala em um diretÃ³rio temporÃ¡rio (sandbox).

qmerge â†’ faz o merge final no sistema (instala de fato).

digest â†’ gera checksums (antigo, substituÃ­do por manifest).

clean â†’ limpa diretÃ³rios temporÃ¡rios.

test â†’ roda testes definidos no ebuild.


Exemplo prÃ¡tico:

cd /var/db/repos/qmeta/extra/nano
qmeta nano-7.2.meta manifest fetch compile install qmerge clean

âš ï¸ Normalmente vocÃª nÃ£o roda isso tudo manualmente â€” o qmeta faz essa sequÃªncia automaticamente.


